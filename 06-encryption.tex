\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsthm}

\usepackage{amsthm,amsmath,amsfonts,amssymb,amstext,enumitem}
\usepackage{latexsym,ifthen,url,rotating,graphicx}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,positioning,fit}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}



% --- -----------------------------------------------------------------
% --- Document-specific definitions.
% --- -----------------------------------------------------------------
\lstset{
    columns=fixed,
    literate={—}{{---}}1 {…}{{...}}1
}

\newcommand{\todo}[1]{{\color{red}[TODO:{#1}]}}

\newtheorem{problem}{Problem}
\newtheorem{corollary}{Corollary}
\newtheorem{fact}{Fact}
\newtheorem{exercise}{Exercise}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}

\newcommand{\getsr}
  {{\:\stackrel{\raisebox{-2pt}{${\scriptscriptstyle \hspace{0.2em}\$}$}}
   {\leftarrow}\:}}
\newcommand{\points}[1]{\textbf{({#1} pts)}}

\newcommand{\Colon}{\ : \ }
\newcommand{\st}{\mathsf{state}}
\newcommand{\msgs}{\mathcal{M}}
\newcommand{\ctxts}{\mathcal{C}}
\newcommand{\keys}{\mathcal{K}}
\newcommand{\rands}{\mathcal{R}}
\newcommand{\states}{\mathcal{S}}
\newcommand{\kg}{\mathcal{K}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\MAC}{\mathrm{MAC}}
\newcommand{\RMAC}{\mathrm{RMAC}}

\newcommand{\pk}{pk}
\newcommand{\sk}{sk}

\newcommand{\calD}{\mathcal{D}}
\newcommand{\AES}{\mathsf{AES}}

\newcommand{\algorithm}[1]{\textbf{Alg} {#1}}

\newcommand{\calO}{\mathcal{O}}

\newcommand{\dlog}{\mathrm{dlog}}

\newcommand{\Adv}{\mathbf{Adv}}
\newcommand{\AdvPRF}[2]{\Adv^{\mathrm{prf}}_{#1}({#2})}
\newcommand{\AdvPRG}[2]{\Adv^{\mathrm{prg}}_{#1}({#2})}
\newcommand{\AdvCPA}[2]{\Adv^{\mathrm{ind{-}cpa}}_{#1}({#2})}
\newcommand{\AdvCCA}[2]{\Adv^{\mathrm{ind{-}cca}}_{#1}({#2})}
\newcommand{\AdvKR}[2]{\Adv^{\mathrm{kr}}_{#1}({#2})}
\newcommand{\AdvCKR}[2]{\Adv^{\mathrm{ckr}}_{#1}({#2})}
\newcommand{\AdvRMR}[2]{\Adv^{\mathrm{rmr}}_{#1}({#2})}
\newcommand{\AdvCR}[2]{\Adv^{\mathrm{cr}}_{#1}({#2})}
\newcommand{\AdvUFCMA}[2]{\Adv^{\textrm{uf{-}cma}}_{#1}({#2})}
\newcommand{\AdvDL}[2]{\Adv^{\mathrm{dl}}_{#1}({#2})}

\newcommand{\Exp}{\mathbf{Exp}}
\newcommand{\ExpOW}[1]{\Exp^{\mathrm{ow}}({#1})}
\newcommand{\ExpCKR}[2]{\Exp^{\mathrm{ckr}}_{#1}({#2})}
\newcommand{\ExpRMR}[2]{\Exp^{\mathrm{rmr}}_{#1}({#2})}

\newcommand{\concat}{{\,\|\,}}
\newcommand{\xor}{\oplus}
\newcommand{\bits}{\{0,1\}}

\newcommand{\tcolh}{T^{\mathrm{col}}_h}
\newcommand{\tcolH}{T^{\mathrm{col}}_{H^2}}
\newcommand{\Hcomb}{H^{1\|2}}
\newcommand{\Hxor}{H^{1\oplus2}}

\newcommand{\EXP}{\textrm{EXP}}
\newcommand{\MODEXP}{\textrm{MOD{-}EXP}}
\newcommand{\ADD}{\textrm{ADD}}
\newcommand{\MULTIMODEXP}{\textrm{MULTI{-}MOD{-}EXP}}
\newcommand{\MUL}{\textrm{MUL}}
\newcommand{\MOD}{\textrm{MOD}}

\newcommand{\GG}{\mathbb{G}}
\newcommand{\ZZ}{\mathbb{Z}}

\newcommand{\bK}{\mathbf{K}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bC}{\mathbf{C}}

\newcommand{\rvrange}{\mathcal{R}}
\newcommand{\rspace}{\mathcal{C}}

\newcommand{\hatalpha}{\hat{\alpha}}

\newcommand{\barm}{\overline{m}}

\newcommand{\otp}{\mathrm{OTP}}
\newcommand{\des}{\mathrm{DES}}
\newcommand{\twodes}{\mathrm{2DES}}
\newcommand{\threedes}{\mathrm{3DES}}
\newcommand{\threedestwo}{\mathrm{3DES2}}
\newcommand{\aes}{\mathrm{AES}}
\newcommand{\pad}{\mathsf{pad}}
\newcommand{\unpad}{\mathsf{unpad}}

\newcommand{\Img}{\mathrm{Im}}

% --- -----------------------------------------------------------------
% --- Lecture notes formatting macros
% --- -----------------------------------------------------------------

%
% The following commands set up the lecnum (lecture number)
% counter and make various numbering schemes work relative
% to the lecture number.
%
\newcounter{lecnum}
%\renewcommand{\thepage}{\thelecnum-\arabic{page}}
\renewcommand{\thesection}{\thelecnum.\arabic{section}}
\renewcommand{\theexercise}{\thelecnum.\arabic{exercise}}
\renewcommand{\theexample}{\thelecnum.\arabic{example}}
\renewcommand{\thedefinition}{\thelecnum.\arabic{definition}}
\renewcommand{\theequation}{\thelecnum.\arabic{equation}}
\renewcommand{\thefigure}{\thelecnum.\arabic{figure}}
\renewcommand{\thefact}{\thelecnum.\arabic{fact}}
\renewcommand{\thetable}{\thelecnum.\arabic{table}}


%
% The following macro is used to generate the header.
%
\newcommand{\lecture}[2]{
   %\pagestyle{myheadings}
   %\thispagestyle{plain}
   \newpage
   \setcounter{lecnum}{#1}
   \setcounter{page}{1}
   \noindent
   \begin{center}
   \framebox{
      \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CMSC 28400 Introduction to Cryptography
                        \hfill Autumn 2019} }
       \vspace{4mm}
       \hbox to 6.28in { {\Large \hfill #2 \hfill} }
       \vspace{2mm}
       \hbox to 6.28in { {\it Instructor: David Cash} \hfill }
      \vspace{2mm}}
   }
   \end{center}
   %\markboth{Lecture #1: #2}{Lecture #1: #2}
   \vspace*{4mm}
}





% --- -----------------------------------------------------------------
% --- The document starts here.
% --- -----------------------------------------------------------------
\begin{document}
%\lecture{**LECTURE-NUMBER**}{**DATE**}{**LECTURER**}{**SCRIBE**}
\lecture{6}{Notes \#6: Symmetric Encryption}

\tableofcontents

\noindent\hrulefill
\bigskip

So far we have learned about block ciphers, which provide a primitive form of
encryption. However you can't use a bare block cipher and expect much: As they
are defined, they only handle a fixed amount of data (e.g. 8 bytes for DES or
16 bytes for AES), and they are ``deterministic'' in the sense that if
you run a block cipher with the same key and message twice, you'll get the
same ciphertext output twice, possibly enabling frequency analysis.

We also covered stream ciphers, and sketched how one could define a ``pseudo
one-time pad'' for using them, but we haven't clarified some important issues,
like exactly how one avoids reusing the pad in practice.

In these notes we begin to build general purpose ``encryption'' from block
ciphers. We start by defining the \emph{syntax} (i.e.  input/output behavior)
of what exactly we want separately from the \emph{security} we want. Security
will have to wait for next time.

\section{Introduction to Symmetric Encryption}

In order to prevent frequency analysis, we need our encryption method to emit
possibly different ciphertexts when fed with the same key and message. In
practice this is done via two general methods: The first is to have the module
running encryption select a random value to mix into encryption. The second
is to have some persistent ``state'' inside of the encryption module that is
updated between runs. We define these separately in this section.

\subsection{Randomized Encryption}

Let's start with the definition.
\begin{definition}
    A pair of functions $\Pi=(\Enc,\Dec)$,
    \begin{align*}
        \Enc  : \keys\times\msgs\times\rands  \to  \ctxts 
    \end{align*}
    and
    \begin{align*}
        \Dec : \keys\times\ctxts \to \msgs,  
    \end{align*}
    is called a \emph{randomized encryption scheme with key-space $\keys$,
    message-space $\msgs$, randomness-space $\rands$, and ciphertext-space
    $\ctxts$} if for every $k\in\keys$, $m\in\msgs$, $r\in\rands$, and
    $c\in\ctxts$
    \begin{align*}
        \Enc(k,m,r)=c \quad \implies \quad \Dec(k,c)=m.
    \end{align*}
\end{definition}
The intended usage is for someone to pick $r\in\rands$ and then run
$c\gets\Enc(k,m,r)$. An interesting point is that decryption must work with $k$
and $c$ \emph{only}. In particular, the value $r$ chosen by the sender is not
assumed to be available for decryption unless it is communicated in $c$; Of
course one can always put $r$ there, but doing so may have implications for
security.

\subsection{Stateful Encryption}

The other way is to maintain state. We'll abstractly define an encryption
algorithm that takes an extra input from a ``state-space'' instead of a
randomness space. The main difference from above is that encryption can output
an updated state that should be used on the next run.
\begin{definition}
    A pair of functions $\Pi=(\Enc,\Dec)$,
    \begin{align*}
        \Enc  : \keys\times\msgs\times\states  \to  \ctxts\times\states
    \end{align*}
    and
    \begin{align*}
        \Dec : \keys\times\ctxts \to \msgs,  
    \end{align*}
    is called a \emph{stateful encryption scheme with key-space $\keys$,
    message-space $\msgs$, state-space $\states$, and ciphertext-space
    $\ctxts$} if for every $k\in\keys$, $m\in\msgs$, $s\in\states$,
    and $c\in\ctxts$
    \begin{align*}
        \Enc(k,m,s)=(c,s') \quad \implies \quad \Dec(k,c)=m.
    \end{align*}
\end{definition}

The intended usage for stateful encryption is for a sender to initialize
$s$ to some default value or a random value. Then, whenever the sender
wants to encrypt a message $m$, it computes $(c,s') \gets \Enc(m,k,s)$ with the
current value of $s$. The output $c$ is meant to be sent, while the output
$s'$ is meant to be kept private as the new state. (That is, $s'$ overwrites
$s$ in the sender's memory.) The next encryption proceeds similarly, producing
a ciphertext and a new state that overwrites the old one.

The definition above requires that $\Enc$ and $\Dec$ work together for
\emph{any} state, so the iterative usage we just sketched is not represented in
the definition. However when we look at security, it will be. At a high level,
we'll define security to only provide guarantees if that template is followed.


\section{Symmetric Encryption with the AES Block Cipher}

In this section we give some of the standard constructions of encryption
from a block cipher. For the rest of the section, we fix the block cipher
\[
    \aes :\bits^{128} \times \bits^{128} \to \bits^{128}.
\]

\subsection{Padding}

All of the encryption modes in this section will have message $\msgs$ equal to
arbitrary-length byte strings (that is, bit strings with length a multiple of
$8$).  The AES block cipher we want to work with, however, only accepts exactly
16 bytes as input. Thus at a few points we will need to ``pad'' a string to be
a multiple of 16 bytes long.

At first padding seems easy (``just add zeros'') but in order to be useful
the padding must be reversible, meaning that someone should be able to remove
the padding and arrive at the same message.

To that end, we define a function $\pad$ that accepts a byte-string of
arbitrary length. On input $m$, $\pad(m)$ will add between $1$ and $16$ bytes
(note that it \emph{always} adds at least one byte). To decide how many,
$\pad(m)$ looks at the number of bytes needed to make $m$ a multiple of $16$
bytes long; call this number $N$. If $m$ is already a multiple of 16 bytes
long, it sets $N=16$. Finally $\pad(m)$ adds $N$ bytes with hex value $0xN$.
So if one byte needs to be added, $\pad$ appends $0x01$. If two bytes are
added, then it appends $0x0202$, etc.

\begin{example}
    Suppose $m$ is the byte string 
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01},
    \]
    where the pairs of digits represent bytes in hex.
    This string is $8$ bytes long, so $8$ bytes needed to be added.
    The output of $\pad(m)$ is
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01\ 08\ 08\ 08\ 08\ 08\ 08\ 08\ 08}
    \]
\end{example}

You can check that it is possible to remove the padding from a string
unambiguously. We'll call that function $\unpad$. We note that some strings
have invalid padding, meaning that $\pad$ would never output them.
\begin{example}
    Consider the byte string
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01\ 06\ 06\ 06\ 06\ 05\ 05\ 05\ 05}.
    \]
    This string is not properly padded, because it only ends with $4$ bytes
    with hex value $0x05$ at the end.

    On the other hand, the byte string
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01\ 06\ 06\ 06\ 06\ 05\ 05\ 05\ 01}.
    \]
    \emph{is} properly padded, because it ends in one $0x01$ byte.

    This is somewhat more subtle than it looks at first. The string
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01\ 06\ 06\ 06\ 06\ 01\ 01\ 01\ 01}.
    \]
    is also properly padded, because it ends in one $0x01$ byte (the other
    $0x01$ bytes are actually message bytes).
\end{example}
This is called PKCS\#7 padding; You can read about it here, amongst other
places:
\url{https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS#5_and_PKCS#7}.


\subsection{Construction\#1: AES-ECB}

Our first construction isn't randomized or stateful; It's just a plain cipher.
Nonetheless, it is sometimes used, often with catastrophic consequences.

This mode is called \emph{ECB}, for ``electronic codebook.'' 
The key-space is $\keys=\bits^{128}$ and the message-space $\msgs$ is
consists of bytestrings of arbitrary length.
The code is
as follows:
\begin{center}
    \begin{tabular}{c|c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m)$}} \\[2pt]
            \> $\barm \gets \pad(m)$\\
            \> Parse $\barm[1]\|\cdots\|\barm[t]\gets\barm$ \\
            \> For $i=1,\ldots,t$:\\
            \> \> $c[i] \gets \aes(k,\barm[i])$\\
            \> $c \gets c[1]\|\ldots\|c[t]$\\
            \> Output $c$
        \end{tabbing}\end{minipage}
        &
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Dec(k,m)$}} \\[2pt]
            \> Parse $c[1]\|\ldots\|c[t]\gets c$ \\
            \> For $i=1,\ldots,t$:\\
            \> \> $\barm[i] \gets \aes^{-1}(k,c[i])$\\
            \> $\barm \gets \barm[1]\| \cdots \|\barm[t]$\\
            \> $m \gets \unpad(\barm)$\\
            \> Output $m$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
In words, encryption pads the message $m$ up to a multiple of the
block size, and then parses the padded version into blocks. Then it
applies $\aes$ to each block and concatenates the blocks. Decryption
parses the ciphertext into blocks, and applies $\aes^{-1}$ to each
block, and finally unpads the result.

In a real implementation, the unpadding step may encounter a message that
is not a valid padding (say, if an adversary were to feed in a block that
is mistakenly decrypted). In that case, we should allow $\Dec$ to output
an error symbol instead of $m$.

\subsection{Construction\#2: AES-CBC with Random IV}

The next encryption scheme, called \emph{CBC} for ``cipher block chaining with
a random IV'' is randomized. The term ``IV'' stands for \emph{initialization
vector},  and refers to the randomness used. The code is as follows:

The key-pace and randomness-space for AES-CBC are $\keys=\rands=\bits^{128}$.
The message space is any byte string.
\begin{center}
    \begin{tabular}{c|c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,r)$}} \\[2pt]
            \> $\barm \gets \pad(m)$\\
            \> Parse $\barm[1]\|\cdots\|\barm[t]\gets\barm$ \\
            \> $c[0] \gets r$ \\
            \> For $i=1,\ldots,t$: \\
            \> \> $c[i] \gets \aes(k,c[i-1]\oplus\barm[i])$\\
            \> $c \gets c[0]\|\ldots\|c[t]$\\
            \> Output $c$
        \end{tabbing}\end{minipage}
        &
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Dec(k,m)$}} \\[2pt]
            \> Parse $c[0]\|\ldots\|c[t]\gets c$ \\
            \> For $i=1,\ldots,t$: \\
            \> \> $\barm[i] \gets \aes^{-1}(k,c[i])\oplus c[i-1]$\\
            \> $\barm \gets \barm[1]\| \cdots \|\barm[t]$\\
            \> $m \gets \unpad(\barm)$\\
            \> Output $m$ \\ 
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
The encryption algorithm pads the message and parses into blocks. Then
it computes the output $c$ by setting the initial block to $c[0]$,
and the computing the $i$\textsuperscript{th} by XOR-ing the previous
ciphertext block with the current message block, and applying $\aes$.
The ciphertext is the concatenation of the blocks.
Decryption undoes encryption in a direct way. It parses out the ciphertext
blocks, and then recovers the $i$\textsuperscript{th} ciphertext block
by applying $\aes^{-1}$ and XOR-ing with the previous ciphertext block.

What's going on here? CBC is trying to eliminate repeated blocks, and defeat
frequency analysis. Intuitively, if $r$ is chosen randomly, then it should
essentially never repeat. But then the first input, $c[0]\oplus\barm[1]$,
will also essentially never repeat. Then, inductively, we can sort of claim
the same should hold for all of the ciphertext blocks. That's a long way from
a sort of proof, but it is the design rationale.

Finally we note that CBC decryption may also encounter a malformed string when
it attempts to unpad. In that case decryption should throw an error.

\subsection{Construction\#3: AES-CBC with Stateful IV}
Our next cipher is a stateful variant of CBC. It uses its state as the first
ciphertext block, and in this particular version, saves the last ciphertext
block as the new state.
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,s)$}} \\[2pt]
            \> $\barm \gets \pad(m)$\\
            \> Parse $\barm[1]\|\cdots\|\barm[t]\gets\barm$ \\
            \> $c[0] \gets s$ \\
            \> For $i=1,\ldots,t$: \\
            \> \> $c[i] \gets \aes(k,c[i-1]\oplus\barm[i])$\\
            \> $c \gets c[0]\|\cdots\|c[t]$\\
            \> $s' \gets c[t]$\\
            \> Output $(c,s')$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
Decryption is the same as above and omitted. On the first encryption,
the state is set to a random element of $\bits^{128}$ just like
CBC with a random IV. 

The vague reasoning above about ciphertext blocks not repeating can be applied
here. However, as innocuous as the stateful change may seem, it turns out to be
insecure in most settings where it has been deployed! The attraction is that
the first ciphertext block $c[0]$ can be omitted when it is already known to
the receiver, but the savings comes at a grave cost in security, as we will see.

\subsection{Construction\#4: AES-CTR with Random IV}

The next construction is randomized. It is called \emph{CTR mode}, or
\emph{counter mode}. Compared to CBC with a random IV, it has the advantage of
avoiding padding and thus never encounters mal-formed messages, and produces a
ciphertext exactly 16 bytes longer than its input message.

This construction has $\keys=\rands=\bits^{128}$ and accepts any byte string as
a message. It will do addition with elements of $\bits^{128}$ by treating them
as integers modulo $2^{128}$ (in practice, the wrapping should essentially
never happen though).  The code is as follows:
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,r)$}} \\[2pt]
            \> Parse $m[1]\|\cdots\|m[t]\gets m \quad $ 
                    \emph{//$m[t]$ may be less than $16$ bytes}\\
            \> $c[0] \gets r$ \\
            \> For $i=1,\ldots,t-1$: \\
            \> \> $c[i] \gets \aes(k,r+i\bmod 2^{128})\oplus m[i]$\\
            \> $c[t] \gets \aes(k,r+t\bmod 2^{128})\oplus m[t] \quad$ 
                    \emph{//truncate pad if needed}\\
            \> $c \gets c[0]\|\cdots\|c[t]$\\
            \> Output $c$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
The comment about truncation means that we can only use enough bytes of
$\aes(k,r+t\bmod 2^{128})$ to equal the length of $m[t]$. Intuitively,
CTR mode is simply computing a ``pseudo one-time pad'' by computing
$\aes(k,r+1),\aes(k,r+2),\ldots$ and taking as many bits as needed 
to XOR against the message. 

Decryption does what you'd expect. Note that it needs the value of
$c[0]$ to know where to start computing the pad.
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Dec(k,c)$}} \\[2pt]
            \> Parse $c[0]\|\cdots\|c[t]\gets c \quad $ 
                    \emph{//$c[t]$ may be less than $16$ bytes}\\
            \> $r \gets c[0]$ \\
            \> For $i=1,\ldots,t-1$: \\
            \> \> $m[i] \gets \aes(k,r+i\bmod 2^{128})\oplus c[i]$\\
            \> $m[t] \gets \aes(k,r+t\bmod 2^{128})\oplus c[t] \quad$ 
                    \emph{//truncate pad if needed}\\
            \> $m \gets m[0]\|\cdots\|m[t]$\\
            \> Output $m$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
This is a good cipher, but it may fail if the value of $r$ repeats -- Then
it would effectively reuse a one-time pad.

\subsection{Construction\#5: AES-CTR with Stateful IV}
The final cipher is a variant of CTR that manages state instead of randomness.
It can be run in practice by setting $s=0$ on the first run.
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,s)$}} \\[2pt]
            \> Parse $m[1]\|\cdots\|m[t]\gets m \quad $ 
                    \emph{//$m[t]$ may be less than $16$ bytes}\\
            \> $c[0] \gets s$ \\
            \> For $i=1,\ldots,t-1$: \\
            \> \> $c[i] \gets \aes(k,r+i\bmod 2^{128})\oplus m[i]$\\
            \> $c[t] \gets \aes(k,r+t\bmod 2^{128})\oplus m[t] \quad$ 
                    \emph{//truncate pad if needed}\\
            \> $c \gets c[0]\|\ldots\|c[t]$\\
            \> $s' \gets s+t$\\
            \> Output $(c,s')$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
Decryption is exactly as in CTR with a randomized IV. This version of CTR
has the advantage of never repeating a one-time-pad, as it is effectively
impossible to run the counter until it wraps modulo $2^{128}$.

\begin{exercise}
    Consider the following encryption algorithm:
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,r)$}} \\[2pt]
            \> $\barm \gets \pad(m)$\\
            \> Parse $\barm[1]\|\cdots\|\barm[t]\gets\barm$ \\
            \> $c[0] \gets r; d[0] \gets r$ \\
            \> For $i=1,\ldots,t$: \\
            \> \> $d[i] \gets \aes(k,d[i-1])$\\
            \> \> $c[i] \gets d[i]\oplus\barm[i]$\\
            \> $c \gets c[0]\|\ldots\|c[t]$\\
            \> Output $c$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
Find a decryption algorithm for this construction.
\end{exercise}

\end{document}

